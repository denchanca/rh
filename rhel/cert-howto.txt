RHEL 9 CERTIFICATE ROTATION – EXPANSIVE HOW‑TO (AKV + MANAGED IDENTITY + CERTLC)

Audience: Operators, DevOps engineers, and platform owners who will run and support the RHEL9 golden images and want a battle‑tested certificate rotation pattern that preserves immutability.

--------------------------------------------------------------------
0) TL;DR
--------------------------------------------------------------------
• We use Azure Key Vault (AKV) as the source of truth for X.509 certs/keys. 
• VMs use a Managed Identity (no secrets) to fetch certs at runtime.
• For Linux distros where the Key Vault VM extension isn’t available or usable, Microsoft recommends scheduling the CERTLC script to poll AKV and place updated certs on disk. That’s exactly what we do. [Ref: Azure Architecture Center] 
• Our systemd timer runs hourly (with jitter), compares the current on‑disk cert/key against the latest AKV version, and only restarts the target service if the material has actually changed. 
• The golden image stays immutable: no certs are baked in; rotation is done after boot, safely and idempotently.

Why this is best practice
• No embedded credentials in the image; AKV provides central governance, RBAC, versioning, and audit. 
• Rotations and emergency rollbacks are centralized (flip the active secret/cert version in AKV; VMs follow). 
• Managed Identity eliminates long‑lived credentials and aligns with Microsoft guidance. 
• Behavior matches Microsoft’s certificate lifecycle reference architecture for Linux. 

Citations: 
• Azure certificate lifecycle architecture incl. Linux fallback script (“script_for_not_supported_ARC_on_Linux_distro”): Microsoft Learn. 
• Managed Identity token acquisition for services/VMs: Microsoft Learn. 
• AKV RBAC roles for secrets/certificates, “Key Vault Secrets User”, “Key Vault Certificate User”: Microsoft Learn.

--------------------------------------------------------------------
1) CONCEPTUAL MODEL
--------------------------------------------------------------------
Actors and stores
• Azure Key Vault (AKV): holds either (a) a PEM secret, or (b) a certificate object (CER) plus an associated secret that contains private key (for exportable keys), or (c) an HSM‑backed non‑exportable key used with a cert (less common for file‑based apps). 
• VM (RHEL9): has a system‑ or user‑assigned Managed Identity (MI). 
• CERTLC runner: a scheduled process (systemd service + timer) that uses MI to read AKV and write the cert/key to the expected file paths with 0600 permissions. 
• Workload: nginx, haproxy, java keystore, etc. The runner can optionally restart the service if cert/key changed.

Two storage patterns in AKV (choose one)
A) Single PEM secret pattern (“pem mode”)
   • AKV Secret ‘service‑tls‑pem’ holds a full PEM bundle (private key + cert chain). 
   • VM requires “Key Vault Secrets User” on the vault scope (RBAC) to read secret value. 
   • Runner writes to /etc/pki/tls/certs/service.pem (0600).

B) Certificate object + separate key secret (“pair mode”)
   • AKV Certificate ‘service‑tls’ (public chain) + AKV Secret ‘service‑tls‑key’ (private key). 
   • Minimum RBAC: “Key Vault Secrets User” to read the key secret; public CER can be read with “Key Vault Reader” or by using certificate APIs. 
   • Alternatively, “Key Vault Certificate User” can read full certificate contents where supported (verify your org’s policy—this role also implies access to private key material). 
   • Runner writes /etc/pki/tls/certs/service.crt and /etc/pki/tls/private/service.key (0600).

Notes on keys and exportability
• If your security policy mandates non‑exportable keys (HSM), many Linux apps can’t use a file‑less key. In that case use application gateways, front‑door, or TLS termination upstream, or use apps that support HSM via PKCS#11. 
• For typical VM‑resident apps (nginx, java), PEM or pair mode is the pragmatic choice.

--------------------------------------------------------------------
2) PREREQUISITES (ONCE PER ENV)
--------------------------------------------------------------------
1. Create/identify your AKV (per app per environment is recommended).
   az keyvault create -n kv-molina-stg -g rg-shared-stg -l eastus
2. Ensure the vault uses the RBAC permission model (recommended by Microsoft). 
3. Assign RBAC to the VM’s Managed Identity:
   # For PEM secret access:
   az role assignment create --assignee <VM-MI-OBJECT-ID> \
     --role "Key Vault Secrets User" \
     --scope $(az keyvault show -n kv-molina-stg --query id -o tsv)

   # If reading certificate object + key secret, either:
   #   (a) Secrets User + Reader, or
   #   (b) Key Vault Certificate User (read full cert incl. private key if applicable).
   # Choose the minimum your pattern requires.
4. Store your cert material in AKV:
   # PEM pattern (single secret):
   az keyvault secret set --vault-name kv-molina-stg -n service-tls-pem --file ./service.pem

   # Pair pattern (certificate object + key secret):
   az keyvault certificate import --vault-name kv-molina-stg -n service-tls --file ./public_cert_chain.cer
   az keyvault secret set --vault-name kv-molina-stg -n service-tls-key --file ./private.key
5. Enable system‑assigned MI on the VM (or use a user‑assigned MI) and confirm it appears in Entra with an object id. 

Rationale
• RBAC at the vault scope + per‑environment isolation reduces blast radius and supports least privilege. 
• By avoiding access policies and preferring RBAC (Microsoft’s current default), you maintain one consistent authorization model across subscriptions.

--------------------------------------------------------------------
3) HOW THE RUNNER WORKS (OUR IMPLEMENTATION)
--------------------------------------------------------------------
At image build, nothing certificate‑related is baked into the VM. Post‑deploy, Ansible installs:
• /opt/certlc/runner.sh – the orchestrator that attempts to run Microsoft’s official CERTLC zip (if provided), else falls back to an MI‑based fetcher aligned with the same logic. 
• /etc/certlc/certlc.env – configuration (AKV name, secret/cert names, output paths, service to restart). 
• systemd units:
  - certlc-run.service (oneshot) – executes the runner and exits. 
  - certlc-run.timer – schedules periodic runs (default: every 1h with randomized delay for fleet‑friendliness).

Idempotency & change detection
• The runner fetches the latest AKV version (unversioned GET picks the current active). 
• It writes the material to a temp file and uses a byte‑for‑byte comparison vs existing file(s). If different, it atomically replaces the file (install -m 0600) and sets owner/group per config. 
• Only if files changed and RESTART_SERVICE is set, it restarts (e.g., systemctl restart nginx). 
• Because we use MI tokens from the Instance Metadata Service, there are no credentials at rest.

Operational observability
• Logs: journalctl -u certlc-run.service, and /var/log/certlc/fallback.log for the fallback path. 
• You can ship these logs to Log Analytics by enabling syslog collection or a custom AMA table; add a single logger line per run “certlc updated <thumbprint> -> <new-thumbprint>”.

--------------------------------------------------------------------
4) DETAILED WALKTHROUGH
--------------------------------------------------------------------
A) Decide storage mode
• If your app can ingest a unified PEM, pick PEM mode (simpler; single secret read). 
• If your org separates public chain and keys, pick pair mode. Keep the private key in a secret and the public chain as a certificate object (or an additional secret).

B) Configure Ansible variables (group_vars/all.yml)
   enable_certlc: true
   akv_name: "kv-molina-stg"
   # PEM mode:
   cert_object_name: "service-tls-pem"
   target_mode: "pem"
   pem_out_path: "/etc/pki/tls/certs/service.pem"
   cert_restart_service: "nginx"
   certlc_poll_interval: "1h"
   # Optional: use the official Microsoft CERTLC zip + pinned SHA256:
   certlc_zip_url: "https://github.com/Azure/certlc/raw/<pinned-commit>/.scripts/script_for_not_supported_ARC_on_Linux_distro.zip"
   certlc_zip_sha256: "<real-sha256>"

C) Deploy a VM and run post‑deploy playbook
   ansible-playbook -i <host>, -u azureuser --become ansible/postdeploy.yml

D) Validate
• Confirm timer is enabled: systemctl list-timers | grep certlc
• Force a run: systemctl start certlc-run.service
• Check logs: journalctl -u certlc-run.service
• Verify file permissions: ls -l /etc/pki/tls/private/service.key (0600), same for PEM.

E) Rotate a certificate
• Upload a new version to AKV (same secret or certificate name). AKV automatically versions it. 
  Example (PEM mode):
  az keyvault secret set --vault-name kv-molina-stg -n service-tls-pem --file ./service-2025-09.pem
• Do nothing on the VM. At next timer tick, the runner detects the new version, updates files, and restarts the target service (if configured). 
• Emergency rollback is simply “set the previous version active” (or re‑upload the prior PEM).

F) Zero‑downtime patterns (optional)
• Use two file paths and a symlink; the runner writes the new PEM to a versioned file, flips the symlink, and calls a reload (nginx -s reload) instead of hard restart. 
• For Java keystores, rebuild the JKS/PKCS12 in a temp path, then atomic move + process reload.

--------------------------------------------------------------------
5) SECURITY & COMPLIANCE RATIONALE
--------------------------------------------------------------------
• Immutability preserved: certs are runtime state, not image content. 
• Managed Identity aligns with Microsoft guidance; no shared secrets or SAS tokens exist on disk. 
• RBAC roles are least‑privilege:
  - “Key Vault Secrets User” reads secret values (PEM or key secret). 
  - “Key Vault Certificate User” can read certificate contents inc. private key; use only if necessary and approved. 
  - “Key Vault Reader” reads metadata only (safe for inventory/monitoring). 
• AKV provides auditable version history and soft‑delete/immutable protection with purge protection for compliance. 
• Rotations are scheduled and centralized; you can meet 90‑day (or stricter) rotation SLAs and prove it via AKV logs + systemd logs; wire into Azure Monitor as needed.

Threat‑model notes
• No long‑lived credentials on the VM (only ephemeral MI tokens via IMDS). 
• TLS private keys are written with umask 077 and mode 0600. 
• If the runner cannot reach AKV (network or RBAC), it leaves the existing cert in place and logs the failure—no service disruption due to half‑written files. 
• Randomized delay prevents thundering‑herd API bursts against AKV.

--------------------------------------------------------------------
6) OPERATIONAL RUNBOOK
--------------------------------------------------------------------
Routine checks (weekly):
1) Verify the timer ran in the last 24h: systemctl status certlc-run.timer 
2) Scan journal for “certlc” messages and error counts. 
3) Confirm the VM’s MI still has the correct RBAC role at the vault scope. 
4) For PEM mode, ensure only approved owners can update the PEM in AKV.

Planned rotation (example 60 days cadence):
1) Upload the new PEM or update the certificate object/key secret. 
2) Wait for timer to apply (or start the service unit now). 
3) Validate the new cert in the workload endpoint (curl -vk https://host). 
4) If needed, roll back by resetting the prior AKV version as current.

Break‑glass recovery:
• If a bad PEM is posted, revert the AKV version; VMs will revert on next run. 
• If the runner fails on every VM, fix RBAC or network; then start the service unit. 

--------------------------------------------------------------------
7) DIAGNOSTICS & TROUBLESHOOTING
--------------------------------------------------------------------
• 401/403 from AKV: RBAC missing or wrong scope. Confirm MI object ID and role assignment scope = the vault resource ID. 
• 404 from AKV: wrong secret/cert name; confirm cert_object_name and target_mode in /etc/certlc/certlc.env. 
• Service didn’t restart: either no file change detected or RESTART_SERVICE not set. Force change and test. 
• File perms wrong: review OWNER/GROUP in env file; runner enforces 0600 with install. 
• Clock skew: AKV tokens are time‑bound; ensure NTP/time sync works. 
• Corporate proxy: if egress requires proxy, set proxy envs for curl in the service unit (Environment=). 

Useful manual checks:
• Validate MI token locally:
  curl -s -H "Metadata: true" \
    "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https%3A%2F%2Fvault.azure.net" | jq -r .access_token | head -c 20; echo
• Read current PEM version:
  curl -s -H "Authorization: Bearer $TOKEN" \
    "https://kv-molina-stg.vault.azure.net/secrets/service-tls-pem?api-version=7.4" | jq -r '.id'
• Compare cert thumbprint:
  openssl x509 -noout -fingerprint -sha256 -in /etc/pki/tls/certs/service.pem

--------------------------------------------------------------------
8) INTEGRATION NOTES (ADO, ANSIBLE, MONITORING)
--------------------------------------------------------------------
• ADO pipeline builds images only; no certs involved at build time. This keeps images reusable across environments. 
• Ansible post‑deploy toggles cert rotation with enable_certlc=true and sets env variables. 
• Monitoring: ship journal logs to Log Analytics; add an alert on “certlc updated” or error count > 0 per host. 
• Change management: link AKV secret version change to a work item so rotations are traceable to approvals.

--------------------------------------------------------------------
9) WHY THIS APPROACH OUTPERFORMS ALTERNATIVES
--------------------------------------------------------------------
• Baking certs into images couples identity to AMIs/images and breaks immutability; any revocation requires a rebuild/redeploy. 
• Storing certs on random storage (blobs, repos) lacks RBAC/versioning/rotation semantics and weakens auditability. 
• The Linux Key Vault VM extension is not available/appropriate on some distributions; CERTLC’s scheduled script is Microsoft’s recommended mechanism for Linux when the extension isn’t usable. 
• Using MI avoids SP/password sprawl and secret rotation headaches in pipelines.

--------------------------------------------------------------------
10) APPENDIX – ROLE MAPPING CHEAT SHEET
--------------------------------------------------------------------
If using PEM secret:
  • Required: Key Vault Secrets User (data‑plane). 
  • Optional: Key Vault Reader (metadata viewing only). 

If using certificate object + separate key secret:
  • Minimum: Key Vault Secrets User (to read key secret) + Reader for certificate metadata.
  • Alternative: Key Vault Certificate User (can read the certificate including secret portion when applicable). Validate against your org’s policy and exportability rules.

Scope best practice:
  • Assign roles at the vault scope for the VM’s Managed Identity. Avoid subscription‑wide grants. Use separate vaults per application per environment to simplify least privilege and rollbacks.


